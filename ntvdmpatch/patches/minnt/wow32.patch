--- NT4\private\mvdm\wow32\precomp.h
+++ nt\private\mvdm\wow32\precomp.h
19a20,27
> // WOW32 should compile as NT 6 for best compatibility with newer systems 
> #undef WINVER
> #define WINVER 0x600
> #undef _WIN32_IE 
> #define _WIN32_IE 0x0601
> #undef _WIN32_WINNT
> #define _WIN32_WINNT 0x600
> #define WSABASEERR 10000    // New SDK has WSA error codes defined in winerror.h, prevent inclusion as we include winsock.h 
115a124
> #include "wsyslevel.h"
--- NT4\private\mvdm\wow32\hack.c
+++ nt\private\mvdm\wow32\hack.c
201a202,205
> #ifdef W10 /* On Win10, this calls RtlAllocateHeap internally. If we use ZwAllocate instead, we will crash on free */
>         if (lpEnvNew = RtlAllocateHeap(GetProcessHeap(), 0, MemoryInformation.RegionSize))
>             Status = STATUS_SUCCESS; else Status = STATUS_NO_MEMORY;
> #else
207a212
> #endif
--- NT4\private\mvdm\wow32\wshimdb.c
+++ nt\private\mvdm\wow32\wshimdb.c
499a500,503
> #ifdef W10 /* On Win10, this calls RtlAllocateHeap internally. If we use ZwAllocate instead, we will crash on free */
>         if (lpEnvNew = RtlAllocateHeap(GetProcessHeap(), 0, MemoryInformation.RegionSize))
>             Status = STATUS_SUCCESS; else Status = STATUS_NO_MEMORY;
> #else
505a510
> #endif
--- NT4\private\mvdm\wow32\intthunk.c
+++ nt\private\mvdm\wow32\intthunk.c
51a52,54
>     #ifdef W10
>     DECLARE_THUNKLOCK
>     #endif
165a169,171
>     #ifdef W10	// Win32 functions can Send messages to 16bit window, so these windows must be able to reply
> 	if (((*pbInstr & IT_HUSER)  || (*pbInstr & IT_HGDI))) { RELEASE_THUNKLOCK; }
>     #endif
174a182,184
>     #ifdef W10
>     if (((*pbInstr & IT_HUSER)  || (*pbInstr & IT_HGDI))) { RESTORE_THUNKLOCK; }
>     #endif
--- NT4\private\mvdm\wow32\wcall16.c
+++ nt\private\mvdm\wow32\wcall16.c
844a845,847
> #ifdef W10
>     _EnterWin16Lock();
> #endif
858a864,866
> #ifdef W10
>      _LeaveWin16Lock();
> #endif
--- NT4\private\mvdm\wow32\wcommdlg.c
+++ nt\private\mvdm\wow32\wcommdlg.c
2088a2089
>     DECLARE_THUNKLOCK
2207a2209
>     RELEASE_THUNKLOCK
2208a2211
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wddeml32.c
+++ nt\private\mvdm\wow32\wddeml32.c
211a212
>     DECLARE_THUNKLOCK
217a219
>     RELEASE_THUNKLOCK
219a222
>     RESTORE_THUNKLOCK
367a371
>     DECLARE_THUNKLOCK
380a385
>         RELEASE_THUNKLOCK
388a394
>         RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wumsg.c
+++ nt\private\mvdm\wow32\wumsg.c
174a175
>     DECLARE_THUNKLOCK
224a226
>             RELEASE_THUNKLOCK
227a230
>             RESTORE_THUNKLOCK
431a435
>     DECLARE_THUNKLOCK
477a482
>             RELEASE_THUNKLOCK
480a486
>             RESTORE_THUNKLOCK
662a669,671
> #ifdef W10
>         _LeaveWin16Lock();
> #endif
663a673,675
> #ifdef W10
>         _EnterWin16Lock();
> #endif
712a725
>     DECLARE_THUNKLOCK
730a744
>     RELEASE_THUNKLOCK
731a746
>     RESTORE_THUNKLOCK
820a836
>     DECLARE_THUNKLOCK
831c847,853
< 
---
> #ifdef W10
>     if (!PeekMessage(&t1, HWND32(parg16->hwnd), WORD32(parg16->wMin), WORD32(parg16->wMax), PM_REMOVE))
>     {
>          DWORD count;
>          
>          ReleaseThunkLock(&count);
> #endif
835a858,862
> #ifdef W10
>         RestoreThunkLock(count);
>     }
>     else ul = t1.message != WM_QUIT;
> #endif
844a872
> #ifndef W10 /* msctf.dll also seems to use high timer IDs. Therefore removed check */
848a877
> #endif
849a879,883
>     LOGDEBUG(LOG_TRACE,("hWnd = %x, msg %d (0x%x), wParam=%08X, lParam=%08X\n", t1.hwnd, t1.message, t1.message, t1.wParam, t1.lParam)); 
> 
> #ifdef W10	/* Filter WM_TIMER that are useless for 16bit world */
>     if (t1.message != WM_TIMER || HIWORD(t1.wParam) == 0)
> #endif
1115a1150
>     DECLARE_THUNKLOCK
1131a1167,1175
> #ifdef W10
>     if (!fNoYield)
>     {
>         RELEASE_THUNKLOCK
>         //MsgWaitForMultipleObjects(0, NULL, FALSE, 0, QS_ALLINPUT);
>         SwitchToThread();
>     }
> #endif
> 
1132a1177,1179
> #ifdef W10
>     if (!fNoYield) RESTORE_THUNKLOCK  // PeekMessage can call WndProc which can be 16bit code, therefore lock again 
> #endif
1700a1748,1751
> #ifdef W10
>     DECLARE_THUNKLOCK
>     LRESULT lResult;
> #endif
1760a1812,1821
> #ifdef W10
>             RELEASE_THUNKLOCK
>             lResult = SendMessageTimeout(hwndItem, mpex.uMsg, mpex.uParam,
>                                          mpex.lParam, SMTO_NORMAL, 1000, &mpex.lReturn);
>             RESTORE_THUNKLOCK
>             if (!lResult && GetLastError() == ERROR_TIMEOUT)
>             {
>                 LOGDEBUG(LOG_ALWAYS,("BUGBUG: SendDlgItemMessage(%p,%d,%04x,%08x,uTimeout=1000ms) timed out.\n", hwnd, mpex.uMsg, mpex.uParam, mpex.lParam));
>             }
> #else
1762a1824
> #endif
1825a1888,1891
> #ifdef W10
>     DECLARE_THUNKLOCK
>     LRESULT lResult;
> #endif
1904a1971,1982
> #ifdef W10
>         {
>             DWORD count;
>             ReleaseThunkLock(&count);
>             lResult = SendMessageTimeout(hwnd, mpex.uMsg, mpex.uParam, mpex.lParam, SMTO_NORMAL, 1000, &mpex.lReturn);
>             RestoreThunkLock(count);
>             if (!lResult && GetLastError() == ERROR_TIMEOUT)
>             {
>                 LOGDEBUG(LOG_ALWAYS,("BUGBUG: SendMessage(%p,%d,%04x,%08x,uTimeout=1000ms) timed out.\n", hwnd, mpex.uMsg, mpex.uParam, mpex.lParam));
>             }
>         }
> #else
1905a1984
> #endif
2177a2257
>     DECLARE_THUNKLOCK
2180a2261
>     RELEASE_THUNKLOCK
2184a2266
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wkman.c
+++ nt\private\mvdm\wow32\wkman.c
33a34,44
> #ifndef GetAllUsersProfileDirectory
> USERENVAPI BOOL WINAPI GetAllUsersProfileDirectoryA(LPSTR lpProfileDir, LPDWORD lpcchSize);
> USERENVAPI BOOL WINAPI GetAllUsersProfileDirectoryW(LPWSTR lpProfileDir, LPDWORD lpcchSize);
> #ifdef UNICODE
> #define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryW
> #else
> #define GetAllUsersProfileDirectory  GetAllUsersProfileDirectoryA
> #endif // !UNICODE
> #endif 
> 
> 
1022a1034,1047
> #ifdef W10
> void InputIdleCB(HWND Arg1, UINT Arg2, UINT_PTR Arg3, DWORD Arg4)
> {
> #ifdef DEBUG
> 	register PVDMFRAME pFrame;
> 
>     PTD ptd = CURRENTPTD();
> 	GETFRAMEPTR(ptd->vpStack, pFrame);
> #endif
>     LOGDEBUG(LOG_TRACE,("%04X          InputIdleCB\n", pFrame->wTDB));
>     KillTimer(Arg1, Arg3);
>     WOW32VERIFY(SetEvent(ghevWaitCreatorThread));
> }
> #endif
1055a1081,1083
> #ifdef W10
>         DWORD mutex_count;
> #endif
1061a1090,1106
> #ifdef W10
>         ReleaseThunkLock(&mutex_count);
>         while ((dw = MsgWaitForMultipleObjects(2, ThreadEvents, FALSE, INFINITE, QS_SENDMESSAGE)) == WAIT_OBJECT_0+2)
>         {
>             MSG msg;
>             DECLARE_THUNKLOCK
>             
>             RESTORE_THUNKLOCK
>             if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
>             {
>                 TranslateMessage(&msg);
>                 DispatchMessage(&msg);
>             }
>             RELEASE_THUNKLOCK
>         }
>         RestoreThunkLock(mutex_count);
> #else
1062a1108,1109
> #endif
>         LOGDEBUG(LOG_TRACE,("%04X          Wait returned %d\n", pFrame->wTDB, dw));
1063a1111
> #ifndef W10 // Do not assert, as this constellation can occur due to InputIdle logic for ghevWaitCreatorThread
1066a1115
> #endif
1320c1369
<     CURRENTPTD() = &td;
---
>     SETCURRENTPTD(&td);
1505,1508c1554
<         
<         // FIXME: Enable the following when we are ready.
<         gfTaskContinue = TRUE;
<         //gfTaskContinue = CheckAppHelpInfo(&td,szFilePath,szModName);
---
>         gfTaskContinue = CheckAppHelpInfo(&td,szFilePath,szModName);
1561c1607
< #ifdef i386
---
> #ifdef i386xx
1569a1616
> #ifndef W10 /* Unfortunetely, no NtUserInitTask support... */
1604a1652,1654
> #else
>         {
>             static BOOL bFirstCall = TRUE;
1605a1656,1670
>             if (bFirstCall)
>             {
>                 HMODULE hUxTheme = GetModuleHandle("uxtheme.dll");
>                 if (!hUxTheme) hUxTheme = LoadLibrary("uxtheme.dll");
>                 if (hUxTheme)
>                 {
>                     typedef int (__stdcall *pfAddThemeAppCompatFlags)(ULONG ulAppCompatFlags, ULONG ulAppCompatFlagsEx);
>                     pfAddThemeAppCompatFlags AddThemeAppCompatFlags = (pfAddThemeAppCompatFlags)GetProcAddress(hUxTheme, (LPCSTR)67);
>                     if (AddThemeAppCompatFlags) AddThemeAppCompatFlags(2, 0);
>                     bFirstCall = FALSE;
>                 }
>             }
>         }
>         fRet = FALSE;
> #endif
1607a1673
>         td.hThread = hThread;
1626a1693,1694
> #ifdef W10
>             SetTimer(NULL, 0, 10, InputIdleCB);
1627a1696,1697
>             _EnterWin16Lock();
> #else
1628a1699
> #endif
1631d1701
<         td.hThread = hThread;
1832c1902
<     CURRENTPTD() = &td;
---
>     SETCURRENTPTD(&td);
1959c2029
< #ifdef i386
---
> #ifdef i386xx
1967,1971c2037,2039
<     // FIXME: Enable the following when we are ready.
<     /*
<     if(ptd->pWOWCompatFlagsEx_Info) {
<        FreeFlagInfo(ptd->pWOWCompatFlagsEx_Info);
<     }
---
>     if(ptd->pWOWCompatFlagsEx_Info) {
>        FreeFlagInfo(ptd->pWOWCompatFlagsEx_Info);
>     }
1973,1976c2041,2043
<     if(ptd->pWOWCompatFlags2_Info) {
<        FreeFlagInfo(ptd->pWOWCompatFlags2_Info);
<     }
<     */
---
>     if(ptd->pWOWCompatFlags2_Info) {
>        FreeFlagInfo(ptd->pWOWCompatFlags2_Info);
>     }
2170a2238,2241
> #ifdef W10
>     _LeaveWin16Lock();
> 	if (CURRENTPTD()->yield_event) CloseHandle(CURRENTPTD()->yield_event);
> #endif
2237a2309,2316
> #ifdef W10
>     _LeaveWin16Lock();
>     if (ptd->yield_event)
> 	{
> 		CloseHandle(ptd->yield_event);
> 		ptd->yield_event = NULL;
> 	}
> #endif
2378a2458
> #if 0	// leecher1337: Seems to be always be 0 on XP and above? Call Fritz!
2382a2463
> #endif
3028a3110
>     DECLARE_THUNKLOCK
3088a3171
>             RELEASE_THUNKLOCK
3100a3184
>             RESTORE_THUNKLOCK
6095,6099c6179,6182
<         // FIXME: Enable the following when we are ready.
<         /*if (WOWCSIDL_AllUsers == pMatchMapPath->dwCLSID) {
<              cb = sizeof(szBuf);
<              GetAllUsersProfileDirectory(szBuf, &cb);
<              }*/
---
>         if (WOWCSIDL_AllUsers == pMatchMapPath->dwCLSID) {
>              cb = sizeof(szBuf);
>              GetAllUsersProfileDirectory(szBuf, &cb);
>              }
--- NT4\private\mvdm\wow32\wuclass.c
+++ nt\private\mvdm\wow32\wuclass.c
22a23,165
> #ifdef W10
> #define NCCR_DEFAULT		0
> #define NCCR_GETCLASSLONG	1
> #define NCCR_SETCLASSLONG	2
> static BOOL mfNCCRmode = NCCR_DEFAULT;
> struct nccr_scl {
> 	int nIndex;
> 	LONG dwNewLong;
> };
> 
> LRESULT CALLBACK W32Win16WndDispProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
> {
> 	VPWNDPROC vpWndProc16 = (VPWNDPROC)GetProp(hwnd, (LPCTSTR)gidWNDPROC16);
> 	LRESULT ret;
> 
> 	/* Special treatment for SetClassLong and GetClassLong handling for x64GetClassLongByClassname
> 	 * and x64SetClassLongByClassname
> 	 */
> 	if (mfNCCRmode)
> 	{
> 		if (uMsg == WM_NCCREATE)
> 		{
> 			LPCREATESTRUCT lpCS = (LPCREATESTRUCT)lParam;
> 			struct nccr_scl *pSCL;
> 
> 			switch (mfNCCRmode)
> 			{
> 			case NCCR_GETCLASSLONG:
> 				*(DWORD*)lpCS->lpCreateParams = GetClassLong(hwnd, *(int*)lpCS->lpCreateParams);
> 				LOGDEBUG(LOG_TRACE,("W32Win16DlgDispProc GetClassLong = %d\n", *(int*)lpCS->lpCreateParams));
> 				break;
> 			case NCCR_SETCLASSLONG:
> 				pSCL = (struct nccr_scl*)lpCS->lpCreateParams;
> 				*(DWORD*)lpCS->lpCreateParams = SetClassLong(hwnd, pSCL->nIndex, pSCL->dwNewLong);
> 				LOGDEBUG(LOG_TRACE,("W32Win16DlgDispProc SetClassLong = %d\n", *(int*)lpCS->lpCreateParams));
> 				break;
> 			}
> 		} else if (uMsg == WM_NCDESTROY)
> 			mfNCCRmode = NCCR_DEFAULT;
> 		
> 		return 0; /* Let CreateWindow fail */
> 	}
> 
> 	if (!vpWndProc16)
> 	{
> 		if (!(vpWndProc16 = (VPWNDPROC)GetClassLong(hwnd, GCL_MY_WNDPROC)))
> 			return 1;
> 		SetProp(hwnd, (LPCTSTR)gidWNDPROC16, (HANDLE)vpWndProc16);
> 	}
> 	if (IsWOWProc(vpWndProc16) && HIWORD(vpWndProc16) != WNDPROC_HANDLE)
> 		ret = W32Win16WndProcEx(hwnd, uMsg, wParam, lParam, vpWndProc16, NULL);
> 	else
> 		ret = CallWindowProc((WNDPROC)vpWndProc16, hwnd, uMsg, wParam, lParam);
> 	if (uMsg == WM_NCDESTROY)
> 		RemoveProp(hwnd, (LPCTSTR)gidWNDPROC16);
> 
> 	return ret;
> }
> 
> // GetClassLong just by Classname
> DWORD x64GetClassLongByClassname(HINSTANCE hInstance, LPCTSTR lpClassName, int nIndex)
> {
> 	HWND hWnd;
> 
> 	// We assume that the caller already verified that it's a WOW window
> 	// Very expensive call here:
> 	// We need to create a window in order to access the GetClassLong pointer.. Any better ideas?
> 	LOGDEBUG(LOG_TRACE,("x64GetClassLongByClassname(%x, %s, %d)\n", hInstance, lpClassName, nIndex));
> 	mfNCCRmode = NCCR_GETCLASSLONG;
> 	hWnd = x64CreateWindowEx(
> 		   0, lpClassName, "WOWDUMMY", WS_DISABLED | WS_POPUP, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, 0,
> 		   NULL, hInstance?hInstance:GetModuleHandle(NULL), &nIndex);
> 	LOGDEBUG(LOG_TRACE,("x64GetClassLongByClassname after call: hwnd=%x, mfNCCRmode=%d\n", hWnd, mfNCCRmode));
> 	if (mfNCCRmode == NCCR_GETCLASSLONG)
> 	{
> 		LOGDEBUG(LOG_ALWAYS,("x64GetClassLongByClassname called on a window that belongs to class %s doesn't react with W32Win16WndDispProc\n", lpClassName));
> 		mfNCCRmode = NCCR_DEFAULT;
> 		if (hWnd) nIndex = (int)GetClassLong(hWnd, nIndex);
> 		else
> 		{
> 			// Something went terribly wrong here
> 			return 0;
> 		}
> 	}
> 	if (hWnd)
> 	{
> 		// Should not happen, as we fail WM_NCCREATE
> 		DestroyWindow(hWnd);
> 	}
> 	LOGDEBUG(LOG_TRACE,("x64GetClassLongByClassname returns %d\n", nIndex));
> 	return (DWORD)nIndex;
> }
> 
> DWORD x64SetClassLongByClassname(HINSTANCE hInstance, LPCTSTR lpClassName, int nIndex, LONG dwNewLong)
> {
> 	HWND hWnd;
> 	struct nccr_scl scl;
> 
> 	// We assume that the caller already verified that it's a WOW window
> 	// Very expensive call here:
> 	// We need to create a window in order to access the SetClassLong pointer.. Any better ideas?
> 	LOGDEBUG(LOG_TRACE,("x64SetClassLongByClassname(%x, %s, %d, %x)\n", hInstance, lpClassName, nIndex, dwNewLong));
> 	mfNCCRmode = NCCR_SETCLASSLONG;
> 	scl.nIndex = nIndex;
> 	scl.dwNewLong = dwNewLong;
> 	hWnd = x64CreateWindowEx(
> 		   0, lpClassName, "WOWDUMMY", WS_DISABLED | WS_POPUP, 0, 0, CW_USEDEFAULT, CW_USEDEFAULT, 0,
> 		   NULL, hInstance?hInstance:GetModuleHandle(NULL), &scl);
> 	if (mfNCCRmode == NCCR_SETCLASSLONG)
> 	{
> 		LOGDEBUG(LOG_ALWAYS,("x64SetClassLongByClassname called on a window that belongs to class %s doesn't react with W32Win16WndDispProc\n", lpClassName));
> 		mfNCCRmode = NCCR_DEFAULT;
> 		if (hWnd) scl.nIndex = (int)SetClassLong(hWnd, nIndex, dwNewLong);
> 		else
> 		{
> 			// Something went terribly wrong here
> 			return 0;
> 		}
> 	}
> 	if (hWnd)
> 	{
> 		// Should not happen, as we fail WM_NCCREATE
> 		DestroyWindow(hWnd);
> 	}
> 	LOGDEBUG(LOG_TRACE,("x64SetClassLongByClassname returns %d\n", scl.nIndex));
> 	return (DWORD)scl.nIndex;
> }
> 
> BOOL x64GetClassInfo(HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass)
> {
> 	BOOL bRet = GetClassInfo(hInstance, lpClassName, lpWndClass);
> 	if(bRet && lpWndClass->lpfnWndProc == W32Win16WndDispProc)
> 	{
> 		DWORD dwRet;
> 		
> 		dwRet = x64GetClassLongByClassname(hInstance, lpClassName, GCL_MY_WNDPROC);
> 		if (dwRet) lpWndClass->lpfnWndProc = (WNDPROC)dwRet;
> 		lpWndClass->cbClsExtra -= GWL_OFFSET;
> 	}
> 	return bRet;
> }
> #endif /* W10 */
> 
93c236
<     ul = GETBOOL16(GetClassInfo(hInst, pszClass, &t3));
---
>     ul = GETBOOL16(x64GetClassInfo(hInst, pszClass, &t3));
172a316
> #ifndef W10 /* Not implemented on x64 */
189a334
> #endif
263c408
<                 dwProc32 = GetClassLong(hwnd, iOffset);
---
>                 dwProc32 = GetClassLong(hwnd, GCL_MY_WNDPROC);
308c453
<             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA);
---
>             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA) - GWL_OFFSET;
312c457
<             ul = GetClassLong(hwnd, iOffset);
---
>             ul = GetClassLong(hwnd, iOffset + (iOffset>=0?GWL_OFFSET:0));
427c572
<             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA);
---
>             ul = GetClassLong(hwnd, GCL_CBCLSEXTRA) - GWL_OFFSET;
433c578
<             ul = GetClassWord(hwnd, iOffset);
---
>             ul = GetClassWord(hwnd, iOffset + (iOffset>=0?GWL_OFFSET:0));
497a643,645
> #ifdef W10
>     VPWNDPROC lpfnWndProc;
> #endif
531a680,691
> #ifdef W10
>     // Windows 10 x64 Hack: USER32.DLL for some reason doesn't contain 
>     // code to properly dispatch to W32Win16WndProcEx, when Window handle
>     // is marked as seen above.
>     // Therefore we use a hack and replace WndProc with our own wrapper 
>     // that dispatched to W32Win16WndProcEx. Any better ideas?
>     t1.cbClsExtra += GWL_OFFSET;
>     lpfnWndProc    = (VPWNDPROC)t1.lpfnWndProc;
>     t1.lpfnWndProc = W32Win16WndDispProc;
> #endif
> 
> 
555a716,721
> #ifdef W10
>     else
>     {
>         x64SetClassLongByClassname(HMODINST32(LOWORD(t1.hInstance)), pszClass, GCL_MY_WNDPROC, lpfnWndProc);
>     }
> #endif
652c818
<                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_WNDPROC, (LONG)dwWndProc32New);
---
>                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_MY_WNDPROC, (LONG)dwWndProc32New);
664c830
<                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_WNDPROC, l);
---
>                     dwWndProc32Old = SetClassLong(HWND32(parg16->f1), GCL_MY_WNDPROC, l);
717c883
<             if(IsWOWProc (GetClassLong(HWND32(parg16->f1), GCL_WNDPROC))) {
---
>             if(IsWOWProc (GetClassLong(HWND32(parg16->f1), GCL_MY_WNDPROC))) {
723c889
<                 ul = SetClassLong(HWND32(parg16->f1), iOffset, WORD32(parg16->f3));
---
>                 ul = SetClassLong(HWND32(parg16->f1), iOffset, WORD32(parg16->f3) + GWL_OFFSET);
732c898
<             ul = SetClassLong(HWND32(parg16->f1), iOffset, LONG32(parg16->f3));
---
>             ul = SetClassLong(HWND32(parg16->f1), iOffset + (iOffset>=0?GWL_OFFSET:0), LONG32(parg16->f3));
856c1022
<             if(IsWOWProc (GetClassLong(hwnd, GCL_WNDPROC))) {
---
>             if(IsWOWProc (GetClassLong(hwnd, GCL_MY_WNDPROC))) {
858c1024
<                 ul = SetClassLong(hwnd, GCL_CBCLSEXTRA, (LONG)ul);
---
>                 ul = SetClassLong(hwnd, GCL_CBCLSEXTRA, (LONG)ul + GWL_OFFSET);
869c1035
<             ul = SetClassWord(hwnd, iOffset, (WORD)ul);
---
>             ul = SetClassWord(hwnd, iOffset + (iOffset>=0?GWL_OFFSET:0), (WORD)ul);
--- NT4\private\mvdm\wow32\wow32.c
+++ nt\private\mvdm\wow32\wow32.c
57,59c57,59
< CHAR    szLogFile[128];
< int     fLog;
< HANDLE  hfLog;
---
> __declspec(dllexport) CHAR    szLogFile[128];
> __declspec(dllexport) int     fLog;
> __declspec(dllexport) HANDLE  hfLog;
71c71
< INT     iLogLevel;           // logging level;  0 implies none
---
> __declspec(dllexport) INT     iLogLevel;           // logging level;  0 implies none
96a97,101
> #ifdef W10
> #include "wtask.h"
> DWORD gdwTLSWOW32Reserved;
> ATOM  gidWNDPROC16, gidDLGPROC16, gidDLGFLAG16;
> #endif
133c138
< #ifndef _X86_
---
> #ifndef _X86xx_
409a415,419
> #ifdef W10
>         GlobalDeleteAtom(gidWNDPROC16);
>         GlobalDeleteAtom(gidDLGPROC16);
>         GlobalDeleteAtom(gidDLGFLAG16);
> #endif
625c635
< #ifndef _X86_
---
> #ifndef _X86xx_
691a702,724
> #ifdef W10
>     pfnOut.pfnYieldTask = (PFNYIELDTASK)xxxUserYield;
> 	pfnOut.pfnDirectedYield = (PFNDIRECTEDYIELD)xxxDirectedYield;
>     pfnOut.pfnWowWaitForMsgAndEvent = xxxWaitForMsgAndEvent;
>     ptd = malloc_w_or_die(sizeof(TD));
>     gdwTLSWOW32Reserved = TlsAlloc();
>     TlsSetValue(gdwTLSWOW32Reserved, ptd);
>     gidWNDPROC16 = GlobalAddAtom("WNDPROC16");
>     gidDLGPROC16 = GlobalAddAtom("DLGPROC16");
>     gidDLGFLAG16 = GlobalAddAtom("DLGFLAG16");
> #ifdef DEBUG
>     if (GetEnvironmentVariableOem("WOWTRACE", szLogFile, sizeof(szLogFile)))
> 	{
> 		char szLogLvl[32];
> 		if (GetEnvironmentVariableOem("WOWLOGLVL", szLogLvl, sizeof(szLogLvl)))
> 			iLogLevel = atoi(szLogLvl);
> 		fLog = 2;
> 	}
> #endif
>     // create dummy menu window, something like this exists on windows xp created by csrss
>     // but is missing on windows starting with Win 7/conhost
>     CreateWindowExA(0x181, "#32768", "", 0x84800000, 0, 0, 0, 0, NULL, NULL, NULL, NULL);
> #else
692a726
> #endif
1944c1978
< #ifdef _X86_
---
> #ifdef _X86xx_
2136c2170
<                                    FILE_SHARE_WRITE,
---
>                                    FILE_SHARE_WRITE | FILE_SHARE_READ,
--- NT4\private\mvdm\wow32\wudlg.c
+++ nt\private\mvdm\wow32\wudlg.c
22a23,79
> #ifdef W10
> struct init_param {
> 	LPARAM lParam;
> 	WNDPROC  vpDlgProc;
> };
> volatile VPWNDPROC gvpWndProc16 = 0;
> 
> 
> BOOL CALLBACK W32Win16DlgDispProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
> {
> 	VPWNDPROC vpWndProc16;
> 	BOOL bRet;
> 
> 	vpWndProc16 = (VPWNDPROC)GetProp(hwndDlg, (LPCTSTR)gidDLGPROC16);
> 	if (uMsg == WM_INITDIALOG && (!vpWndProc16 || GetProp(hwndDlg, (LPCTSTR)gidDLGFLAG16)))
> 	{
> 		struct init_param *param = (struct init_param*)lParam;
> 		
> 		SetProp(hwndDlg, (LPCTSTR)gidDLGPROC16, (HANDLE)param->vpDlgProc);
> 		vpWndProc16 = (volatile VPWNDPROC)param->vpDlgProc;
> 		lParam = param->lParam;
> 		free_w(param);
> 	}
> 	else
> 	{
> 		if (!vpWndProc16 && gvpWndProc16)
> 		{
> 			/* First set it to global WndProc until we get the real one in WM_INITDIALOG 
> 			 * Better than NULL
> 			 */
> 			SetProp(hwndDlg, (LPCTSTR)gidDLGPROC16, (HANDLE)gvpWndProc16);
> 			SetProp(hwndDlg, (LPCTSTR)gidDLGFLAG16, (HANDLE)1);
> 			vpWndProc16 = gvpWndProc16;
> 			gvpWndProc16 = 0;
> 			LOGDEBUG(LOG_ALWAYS, ("W32Win16DlgDispProc: hWnd %x: vpWndProc=NULL!\n", hwndDlg)); 
> 		}
> 	}
> 	if (!vpWndProc16)
> 	{
> 		LOGDEBUG(LOG_ALWAYS, ("W32Win16DlgDispProc: hWnd %x: vpWndProc=NULL!\n", hwndDlg)); 
> 	}
> 
> 	LOGDEBUG(LOG_TRACE,("W32Win16DlgDispProc (%x, %x, %x, %x) vpWndProc=%x, WOW=%d\n", hwndDlg, uMsg, wParam, lParam, vpWndProc16, IsWOWProc(vpWndProc16)));
> 
> 	if (IsWOWProc(vpWndProc16))
> 		bRet = W32Win16DlgProcEx(hwndDlg, uMsg, wParam, lParam, vpWndProc16, NULL);
> 	else
> 		bRet = CallWindowProc((WNDPROC)vpWndProc16, hwndDlg, uMsg, wParam, lParam);
> 
> 	if (uMsg == WM_NCDESTROY)
> 		RemoveProp(hwndDlg, (LPCTSTR)gidDLGPROC16);
> 	return bRet;
> }
> #endif /* W10 */
> 
> 
> 
142a200,201
>     LPARAM   lParam;
>     DECLARE_THUNKLOCK
172a232,242
> #ifdef W10
>         struct init_param *param = malloc_w(sizeof(struct init_param));
> 
>         param->lParam = (LPARAM) DWORD32(parg16->f5);
>         param->vpDlgProc = (WNDPROC)gvpWndProc16 = vpDlgProc;
>         lParam = (LPARAM)param;
>         vpDlgProc = (WNDPROC)W32Win16DlgDispProc;
>         RELEASE_THUNKLOCK
> #else
>         lParam = (LPARAM) DWORD32(parg16->f5);
> #endif
179c249
<                             (LPARAM) DWORD32(parg16->f5), SCDLG_ANSI));
---
>                             lParam, SCDLG_ANSI));
185c255
<                             (LPARAM) DWORD32(parg16->f5),  SCDLG_CLIENT | SCDLG_ANSI | SCDLG_NOREVALIDATE));
---
>                             lParam,  SCDLG_CLIENT | SCDLG_ANSI | SCDLG_NOREVALIDATE));
190a261
>         RESTORE_THUNKLOCK
598a670
>     DECLARE_THUNKLOCK
603a676
>     RELEASE_THUNKLOCK
617a691
>     RESTORE_THUNKLOCK
751a826
>     DECLARE_THUNKLOCK
754a830
>     RELEASE_THUNKLOCK
760a837
>     RESTORE_THUNKLOCK
806a884
>     DECLARE_THUNKLOCK
811a890
>     RELEASE_THUNKLOCK
817a897
>     RESTORE_THUNKLOCK
964a1045
>     DECLARE_THUNKLOCK
987a1069
>     RELEASE_THUNKLOCK
991a1074
>     RESTORE_THUNKLOCK
1030a1114
>     DECLARE_THUNKLOCK
1033a1118
>     RELEASE_THUNKLOCK
1037a1123
>     RESTORE_THUNKLOCK
1229a1316
>     DECLARE_THUNKLOCK
1247a1335
>     RELEASE_THUNKLOCK
1253a1342
>     RESTORE_THUNKLOCK
1298a1388
>     DECLARE_THUNKLOCK
1303a1394
>     RELEASE_THUNKLOCK
1309a1401
>     RESTORE_THUNKLOCK
1343a1436
>     DECLARE_THUNKLOCK
1353a1447
>     RELEASE_THUNKLOCK
1358a1453
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wuwind.c
+++ nt\private\mvdm\wow32\wuwind.c
751c751,752
<     hwnd32 = (pfnOut.pfnCsCreateWindowEx)(
---
> 
>     hwnd32 = x64CreateWindowEx(
760c761
<                HWND32(parg16->hwndParent),
---
>                (HWND)FULLHWND32(parg16->hwndParent),
763,764c764
<                vpparam,
<                CW_FLAGS_ANSI);
---
>                vpparam);
788c788
<         LOGDEBUG(LOG_WARNING,("  CreateWindow failed, class = %s\n", pszClass));
---
>         LOGDEBUG(LOG_WARNING,("  CreateWindow failed, class = %s, gle=%d\n", pszClass, GetLastError()));
898a899
>     DECLARE_THUNKLOCK
901a903
>     RELEASE_THUNKLOCK
902a905
>     RESTORE_THUNKLOCK
1446c1449
<     register PWW pww;
---
>     register PWW pww = NULL;
1482a1486
> 
1483a1488,1500
> #ifdef W10
>                 switch ( iOffset )
>                 {
>                     case DWL_DLGPROC:
>                         if (dwWndProc32Cur == (DWORD)W32Win16DlgDispProc)
>                             dwWndProc32Cur = (DWORD)GetProp(HWND32(parg16->f1), (LPCTSTR)gidDLGPROC16);
>                         break;
>                     case GWL_WNDPROC:
>                         if (dwWndProc32Cur == (DWORD)W32Win16WndDispProc)
>                             dwWndProc32Cur = (DWORD)GetProp(HWND32(parg16->f1), (LPCTSTR)gidWNDPROC16);
>                         break;
>                 }
> #endif
1610c1627
<     dwThreadID = GetWindowThreadProcessId(HWND32(parg16->f1), &dwProcessID);
---
>     dwThreadID = GetWindowThreadProcessId((HWND)FULLHWND32(parg16->f1), &dwProcessID);
1665a1683
>     DECLARE_THUNKLOCK
1670a1689
>     RELEASE_THUNKLOCK
1671a1691
>     RESTORE_THUNKLOCK
1725c1745
<     PWW pww;
---
>     PWW pww = NULL;
1999a2020
>     DECLARE_THUNKLOCK
2020a2042
>             RELEASE_THUNKLOCK
2022a2045
>             RESTORE_THUNKLOCK
2027a2051
>     RELEASE_THUNKLOCK
2033a2058
>     RESTORE_THUNKLOCK
2105a2131
>     DECLARE_THUNKLOCK
2110a2137
>     RELEASE_THUNKLOCK
2117a2145
>     RESTORE_THUNKLOCK
2175c2203
<     register PWW pww;
---
>     register PWW pww = NULL;
2198a2227
>             LONG    l;
2212d2240
<                 dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, dwWndProc32New);
2214,2217c2242
<                 // If the 32 bit set failed, perhaps because its another process,
<                 // then we want to fail too
<                 if (!dwWndProc32Old)
<                     goto SWL_Cleanup;
---
>                 l = dwWndProc32New;
2223c2248
<                 LONG    l;
---
>                 
2238c2263,2286
<                 dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, l);
---
>             }
> 
> #ifdef W10
>             dwWndProc32Old = GetWindowLong(HWND32(parg16->f1), iOffset);
>             switch ( iOffset )
>             {
>                 case DWL_DLGPROC:
>                     if (dwWndProc32Old == (DWORD)W32Win16DlgDispProc)
>                         dwWndProc32Old = (DWORD)GetProp(HWND32(parg16->f1), (LPCTSTR)gidDLGPROC16);
>                     else
>                         SetWindowLong(HWND32(parg16->f1), iOffset, (LPARAM)W32Win16DlgDispProc);
>                     SetProp(HWND32(parg16->f1), (LPCTSTR)gidDLGPROC16, (HANDLE)l);
>                     break;
>                 case GWL_WNDPROC:
>                     if (dwWndProc32Old == (DWORD)W32Win16WndDispProc)
>                         dwWndProc32Old = (DWORD)GetProp(HWND32(parg16->f1), (LPCTSTR)gidWNDPROC16);
>                     else
>                         SetWindowLong(HWND32(parg16->f1), iOffset, (LPARAM)W32Win16WndDispProc);
>                     SetProp(HWND32(parg16->f1), (LPCTSTR)gidWNDPROC16, (HANDLE)l);
>                     break;
>             }
> #else
>             dwWndProc32Old = SetWindowLong(HWND32(parg16->f1), iOffset, l);
> #endif
2240,2243c2288,2291
<                 // If the 32 bit set failed, perhaps because its another process,
<                 // then we want to fail too
<                 if (!dwWndProc32Old)
<                     goto SWL_Cleanup;
---
>             // If the 32 bit set failed, perhaps because its another process,
>             // then we want to fail too
>             if (!dwWndProc32Old)
>                 goto SWL_Cleanup;
2245d2292
<             }
2306c2353,2354
<         ul = SetWindowLong(HWND32(parg16->f1), iOffset, new);
---
>         ul = SetWindowLong((HWND)FULLHWND32(parg16->f1), iOffset, new);
> 
2387a2436
>     DECLARE_THUNKLOCK
2390a2440
>     RELEASE_THUNKLOCK
2407a2458
>     RESTORE_THUNKLOCK
2499a2551
>     DECLARE_THUNKLOCK
2503a2556
>     RELEASE_THUNKLOCK
2521a2575
>     RESTORE_THUNKLOCK
2548a2603
>     DECLARE_THUNKLOCK
2564a2620
>     RELEASE_THUNKLOCK
2565a2622
>     RESTORE_THUNKLOCK
2615c2672
<     PWW pww;
---
>     PWW pww = NULL;
2632c2689
<     hwnd = HWND32(parg16->f1);
---
>     hwnd = (HWND)FULLHWND32(parg16->f1);
2737a2795
>     DECLARE_THUNKLOCK
2740a2799
>     RELEASE_THUNKLOCK
2743a2803
>     RESTORE_THUNKLOCK
2776a2837,2960
> 
> enum ZBID
> {
> 	ZBID_DEFAULT = 0,
> 	ZBID_DESKTOP = 1,
> 	ZBID_UIACCESS = 2,
> 	ZBID_IMMERSIVE_IHM = 3,
> 	ZBID_IMMERSIVE_NOTIFICATION = 4,
> 	ZBID_IMMERSIVE_APPCHROME = 5,
> 	ZBID_IMMERSIVE_MOGO = 6,
> 	ZBID_IMMERSIVE_EDGY = 7,
> 	ZBID_IMMERSIVE_INACTIVEMOBODY = 8,
> 	ZBID_IMMERSIVE_INACTIVEDOCK = 9,
> 	ZBID_IMMERSIVE_ACTIVEMOBODY = 10,
> 	ZBID_IMMERSIVE_ACTIVEDOCK = 11,
> 	ZBID_IMMERSIVE_BACKGROUND = 12,
> 	ZBID_IMMERSIVE_SEARCH = 13,
> 	ZBID_GENUINE_WINDOWS = 14,
> 	ZBID_IMMERSIVE_RESTRICTED = 15,
> 	ZBID_SYSTEM_TOOLS = 16,
> 
> 	//Windows 10+
> 	ZBID_LOCK = 17,
> 	ZBID_ABOVELOCK_UX = 18,
> };
> 
> typedef HWND    (WINAPI *PFNCSCREATEWINDOWEX10)(DWORD dwExStyle, LPCTSTR lpClassName,
>         LPCTSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HANDLE hInstance, LPVOID lpParam, enum ZBID Band, DWORD Flags);
> 
> 
> /*++
> 	Windows version dependent PFNCSCREATEWINDOWEX to support multiple Windows 
> 	Versions
> --*/
> HWND x64CreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, 
> 					   int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, 
> 					   HANDLE hInstance, LPVOID lpParam)
> {
> 	static int iHasZbid = -1;
>     BOOL fRelease = FALSE;
>     HWND hWndRet;
>     DECLARE_THUNKLOCK
> 
> 	if (iHasZbid < 0)
> 	{
> 		OSVERSIONINFO ovi = {0};
> 
> 		ovi.dwOSVersionInfoSize = sizeof(ovi);
> 		if (GetVersionEx(&ovi))
> 		{
> 			switch (ovi.dwMajorVersion)
> 			{
> 			default:
> 			case 5: /* Windows 2000-XP */
> 				iHasZbid = 0;
> 				break;
> 			case 6: /* Windows Vista, 7, 8 */
> 				switch (ovi.dwMinorVersion)
> 				{
> 				case 0: /* Windows Vista */
> 				case 1: /* Windows 7 */
> 					iHasZbid = 0;
> 					break;
> 				case 2: /* Windows 8.0 */
> 				case 3: /* Windows 8.1 */
> 					iHasZbid = 1;
> 					break;
> 				}
> 				break;
> 			case 10: /* Windows 10 */
> 				iHasZbid = 1;
> 				break;
> 			}
> 		}
> 	}
> 
>     if (hWndParent && IsWindow(hWndParent))
>     {
>         DWORD dwWinTid = GetWindowThreadProcessId(hWndParent, NULL);
> 
>         if (!dwWinTid) dwWinTid = GetWindowThreadProcessId(hWndParent, NULL);
>         fRelease = dwWinTid != GetCurrentThreadId();
>     }
>     if (fRelease) RELEASE_THUNKLOCK
> 
> 	if (iHasZbid > 0)
> 	{
> 		hWndRet = (((PFNCSCREATEWINDOWEX10)pfnOut.pfnCsCreateWindowEx))(
> 			   dwExStyle,
> 			   lpClassName,
> 			   lpWindowName,
> 			   dwStyle,
> 			   X,
> 			   Y,
> 			   nWidth,
> 			   nHeight,
> 			   hWndParent,
> 			   hMenu,
> 			   hInstance,
> 			   lpParam,
> 			   ZBID_DEFAULT,
> 			   CW_FLAGS_ANSI);
> 	}
>     else
>     {
>         hWndRet = (pfnOut.pfnCsCreateWindowEx)(
>                dwExStyle,
>                lpClassName,
>                lpWindowName,
>                dwStyle,
>                X,
>                Y,
>                nWidth,
>                nHeight,
>                hWndParent,
>                hMenu,
>                hInstance,
>                lpParam,
>                CW_FLAGS_ANSI);
>     }
>     if (fRelease) RESTORE_THUNKLOCK
>     
>     return hWndRet;
> }
--- NT4\private\mvdm\wow32\wuwind.h
+++ nt\private\mvdm\wow32\wuwind.h
61a62,65
> 
> HWND x64CreateWindowEx(DWORD dwExStyle, LPCTSTR lpClassName, LPCTSTR lpWindowName, DWORD dwStyle, 
> 					   int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, 
> 					   HANDLE hInstance, LPVOID lpParam);
--- NT4\private\mvdm\wow32\wmsg16.c
+++ nt\private\mvdm\wow32\wmsg16.c
130c130
<     lpmpex->hwnd   = HWND32(lpmpex->Parm16.WndProc.hwnd);
---
>     lpmpex->hwnd   = (HWND)FULLHWND32(lpmpex->Parm16.WndProc.hwnd);
1398,1399d1397
<      // FIXME: Enable the following when we are ready.
<      /*
1411d1408
<     */
1674,1675d1670
<     // NOTE: Enable the following when we are ready.
<     /*
1686d1680
<     */
--- NT4\private\mvdm\wow32\wow32.h
+++ nt\private\mvdm\wow32\wow32.h
19a20
> #define W10	// Enable Windows 10 support for some special weird x64 treatment
45c46
< //#include <tsappcmp.h>
---
> #include <tsappcmp.h>
142a144,174
> #ifdef W10
> /* In 64bit Windows, WOW32Reserved is used by WOW64 to store pointer to 
>  * syscall dispatcher, therefore we unfortunately have to reserve our
>  * own slot for WOW32 data
>  */
> extern DWORD gdwTLSWOW32Reserved;
> #define CURRENTPTD()        ((PTD)TlsGetValue(gdwTLSWOW32Reserved))
> #define SETCURRENTPTD(x)	TlsSetValue(gdwTLSWOW32Reserved, x)
> 
> /* Functions that do special treatment to compensate missing scheduler
>  * support in NtUser
>  */
> extern BOOL x64GetClassInfo(HINSTANCE hInstance, LPCTSTR lpClassName, LPWNDCLASS lpWndClass);
> extern ATOM  gidWNDPROC16, gidDLGPROC16, gidDLGFLAG16;
> 
> // Offsets to store our Win16 WndProc in class
> #define GWL_OFFSET			sizeof(VPWNDPROC)
> #define GCL_MY_WNDPROC		0
> 
> // Locking functions for Win16Mutex for our "special" scheduler (wsyslevel.c)
> typedef struct tagSYSLEVEL
> {
>     CRITICAL_SECTION crst;
>     INT              level;
> } SYSLEVEL;
> 
> #define DECLARE_THUNKLOCK	
> #define RELEASE_THUNKLOCK	{_LeaveWin16Lock();}
> #define RESTORE_THUNKLOCK	{_EnterWin16Lock();}
> 
> #else // W10
143a176
> #define SETCURRENTPTD(x)	CURRENTPTD() = x
144a178,185
> #define x64GetClassInfo		GetClassInfo
> #define GWL_OFFSET			0
> #define GCL_MY_WNDPROC		GCL_WNDPROC
> 
> #define DECLARE_THUNKLOCK	
> #define RELEASE_THUNKLOCK	
> #define RESTORE_THUNKLOCK	
> #endif // W10
264a306,311
> #ifdef W10
>     DWORD               sys_count[4];   /* syslevel mutex entry counters */
>     struct tagSYSLEVEL *sys_mutex[4];   /* syslevel mutex pointers */
>     HANDLE              yield_event;    /* yield event */
>     HANDLE              yield_wait_event;/* yield event */
> #endif
306c353
< extern HANDLE hfLog;        // log file handle, if any
---
> extern __declspec(dllexport) HANDLE hfLog;        // log file handle, if any
310c357
< extern INT    iLogLevel;    // logging level;  0 implies none
---
> extern __declspec(dllexport) INT    iLogLevel;    // logging level;  0 implies none
381c428
< #ifndef _X86_
---
> #ifndef _X86xx_
382a430
> #undef pNtVDMState // Wrongly set in vdm.h on x86 
551c599
< #ifndef _X86_  // emulated CPU
---
> #ifndef _X86xx_  // emulated CPU
561c609
< #ifndef _X86_
---
> #ifndef _X86xx_
808c856
< //PTERMSRVCORINIFILE gpfnTermsrvCORIniFile;
---
> PTERMSRVCORINIFILE gpfnTermsrvCORIniFile;
--- NT4\private\mvdm\wow32\wmdisp32.c
+++ nt\private\mvdm\wow32\wmdisp32.c
24a25,27
> #include "comctrlp.h"
> #include "commdlgp.h"
> #include "shlapip.h"
3242,3246c3245,3247
< 
<     // Caller already checked against NM_LAST.
<     if (pnmhdr32->code >= LVN_LAST) {
<         LOGDEBUG(2,("%sLVN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
---
>     // WOWGetNotifySize in notify.c of comctl32 implements this, but
>     // it never got used, even on x86 builds. Why...?
>     switch (pnmhdr32->code) {
3248,3261c3249,3268
<             case LVN_ITEMCHANGING:
<             case LVN_ITEMCHANGED:
<             case LVN_INSERTITEM:
<             case LVN_DELETEITEM:
<             case LVN_DELETEALLITEMS:
<             case LVN_COLUMNCLICK:
<             case LVN_BEGINDRAG:
<             case LVN_BEGINRDRAG:
<             
<             // FIXME: Enable the following when we are ready.
<             /*
<             case LVN_HOTTRACK:
<                 return sizeof(NM_LISTVIEW);
<             */
---
>     // Generic comctl32 notifications
>     case NM_OUTOFMEMORY:        return sizeof(NMHDR);   // not used
> 
>     case NM_CLICK:              return max(max(
>                         sizeof(NMHDR),       // tab, treeview
>                         sizeof(NMCLICK)),    // toolbar, statusbar
>                         sizeof(NMITEMACTIVATE)); // listview
> 
>     case NM_DBLCLK:             return max(max(
>                         sizeof(NMHDR),       // tab, treeview
>                         sizeof(NMCLICK)),    // toolbar, statusbar
>                         sizeof(NMITEMACTIVATE)); // listview
> 
> 
>     case NM_RETURN:             return sizeof(NMHDR);
> 
>     case NM_RCLICK:             return max(max(
>                         sizeof(NMHDR),       // header, listview report mode, treeview
>                         sizeof(NMCLICK)),    // toolbar, statusbar
>                         sizeof(NMITEMACTIVATE)); // listview icon mode
3263,3295c3270,3336
<             case LVN_BEGINLABELEDITA:
<             case LVN_ENDLABELEDITA:
<             case LVN_GETDISPINFOA:
<             case LVN_SETDISPINFOA:
<             case LVN_BEGINLABELEDITW:
<             case LVN_ENDLABELEDITW:
<             case LVN_GETDISPINFOW:
<             case LVN_SETDISPINFOW:
<                 return sizeof(LV_DISPINFO);
< 
<             case LVN_KEYDOWN:
<                 return sizeof(LV_KEYDOWN);
< 
<             case LVN_ODCACHEHINT:
<                 return sizeof(NM_CACHEHINT);
< 
<             case LVN_ODFINDITEMA:
<             case LVN_ODFINDITEMW:
<                 return sizeof(NM_FINDITEM);
< 
<             case LVN_ODSTATECHANGED:
<                 return sizeof(NM_ODSTATECHANGE);
< 
<             // FIXME: Enable the following when we are ready.
<             /*
<             case LVN_ITEMACTIVATE:
<                 return sizeof(NMKEY);
<             */
< 
<             default:
<                 goto unknown_nmhdr_code;
<         }
<     }
---
>     case NM_RDBLCLK:            return max(max(
>                         sizeof(NMHDR),       // treeview
>                         sizeof(NMCLICK)),    // toolbar, statusbar
>                         sizeof(NMITEMACTIVATE)); // listview
> 
>     case NM_SETFOCUS:           return sizeof(NMHDR);
>     case NM_KILLFOCUS:          return sizeof(NMHDR);
>     case NM_STARTWAIT:          return sizeof(NMHDR);      // not used
>     case NM_ENDWAIT:            return sizeof(NMHDR);      // not used
>     case NM_BTNCLK:             return sizeof(NMHDR);      // not used
>     case NM_CUSTOMDRAW:         return sizeof(NMCUSTOMDRAW);
>     case NM_HOVER:              return sizeof(NMHDR);
>     case NM_NCHITTEST:          return sizeof(NMMOUSE);
>     case NM_KEYDOWN:            return sizeof(NMKEY);
>     case NM_RELEASEDCAPTURE:    return sizeof(NMHDR);
>     case NM_SETCURSOR:          return sizeof(NMMOUSE);
>     case NM_CHAR:               return sizeof(NMCHAR);
>     case NM_TOOLTIPSCREATED:    return sizeof(NMTOOLTIPSCREATED);
>     case NM_LDOWN:              return sizeof(NMCLICK);
>     case NM_RDOWN:              return sizeof(NMCLICK);     // not used
>     case NM_THEMECHANGED:       return sizeof(NMHDR);
>     case NM_FONTCHANGED:        return sizeof(NM_FONTCHANGED);
>     case NM_CUSTOMTEXT:         return max(sizeof(NMCUSTOMTEXT),
>                                            sizeof(NMTVSTATEIMAGECHANGING));
>     
> 
>     // Listview notifications
>     case LVN_ITEMCHANGING:      return sizeof(NMLISTVIEW);
>     case LVN_ITEMCHANGED:       return sizeof(NMLISTVIEW);
>     case LVN_INSERTITEM:        return sizeof(NMLISTVIEW);
>     case LVN_DELETEITEM:        return sizeof(NMLISTVIEW);
>     case LVN_DELETEALLITEMS:    return sizeof(NMLISTVIEW);
>     case LVN_BEGINLABELEDITA:   return sizeof(NMLVDISPINFOA);
>     case LVN_BEGINLABELEDITW:   return sizeof(NMLVDISPINFOW);
>     case LVN_ENDLABELEDITA:     return sizeof(NMLVDISPINFOA);
>     case LVN_ENDLABELEDITW:     return sizeof(NMLVDISPINFOW);
>     case LVN_COLUMNCLICK:       return sizeof(NMLISTVIEW);
>     case LVN_BEGINDRAG:         return sizeof(NMITEMACTIVATE);
>     case LVN_BEGINRDRAG:        return sizeof(NMITEMACTIVATE); // not used
>     case LVN_ENDDRAG:           return sizeof(NMITEMACTIVATE); // not used
>     case LVN_ENDRDRAG:          return sizeof(NMITEMACTIVATE); // not used
>     case LVN_ODCACHEHINT:       return sizeof(NMLVCACHEHINT);
>     case LVN_ODFINDITEMA:       return sizeof(NMLVFINDITEMA);
>     case LVN_ODFINDITEMW:       return sizeof(NMLVFINDITEMW);
>     case LVN_ITEMACTIVATE:      return sizeof(NMITEMACTIVATE);
>     case LVN_ODSTATECHANGED:    return sizeof(NMLVODSTATECHANGE);
> //  case LVN_PEN:               // Pen Windows slackers
>     case LVN_HOTTRACK:          return sizeof(NMLISTVIEW);
>     case LVN_GETDISPINFOA:      return sizeof(NMLVDISPINFOA);
>     case LVN_GETDISPINFOW:      return sizeof(NMLVDISPINFOW);
>     case LVN_SETDISPINFOA:      return sizeof(NMLVDISPINFOA);
>     case LVN_SETDISPINFOW:      return sizeof(NMLVDISPINFOW);
>     case LVN_KEYDOWN:           return sizeof(NMLVKEYDOWN);
>     case LVN_MARQUEEBEGIN:      return sizeof(NMITEMACTIVATE);
>     case LVN_GETINFOTIPA:       return sizeof(NMLVGETINFOTIPA);
>     case LVN_GETINFOTIPW:       return sizeof(NMLVGETINFOTIPW);
>     case LVN_GETEMPTYTEXTA:     return sizeof(NMLVDISPINFOA);
>     case LVN_GETEMPTYTEXTW:     return sizeof(NMLVDISPINFOW);
>     case LVN_INCREMENTALSEARCHA:return sizeof(NMLVFINDITEMA);
>     case LVN_INCREMENTALSEARCHW:return sizeof(NMLVFINDITEMW);
>     case LVN_COLUMNDROPDOWN:    return sizeof(NMLISTVIEW);
>     case LVN_COLUMNOVERFLOWCLICK:return sizeof(NMLISTVIEW);
>     case LVN_BEGINSCROLL:       return sizeof(NMLVSCROLL);
>     case LVN_ENDSCROLL:         return sizeof(NMLVSCROLL);
>     case LVN_LINKCLICK:         return sizeof(NMLVLINK);
>     case LVN_GETEMPTYMARKUP:    return sizeof(NMLVEMPTYMARKUP);
>     
3297,3318c3338,3353
<     if (pnmhdr32->code >= PSN_LAST) {
<         LOGDEBUG(2,("%sPSN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
<             case PSN_SETACTIVE:
<             case PSN_KILLACTIVE:
<             case PSN_APPLY:
<             case PSN_RESET:
<             case PSN_HELP:
<             case PSN_WIZBACK:
<             case PSN_WIZNEXT:
<             case PSN_WIZFINISH:
<             case PSN_QUERYCANCEL:
<             
<             // FIXME: Enable the following when we are ready.
<             /*
<             case PSN_TRANSLATEACCELERATOR:
<             case PSN_QUERYINITIALFOCUS:
<             case PSN_HASHELP:          // this one "is dead" - RaymondC
<                 return sizeof(PSHNOTIFY);
< 
<             case PSN_GETOBJECT:
<                 return sizeof(NMOBJECTNOTIFY);
---
>     // Property sheet notifications
>     case PSN_SETACTIVE:         return sizeof(PSHNOTIFY);
>     case PSN_KILLACTIVE:        return sizeof(PSHNOTIFY);
>     case PSN_APPLY:             return sizeof(PSHNOTIFY);
>     case PSN_RESET:             return sizeof(PSHNOTIFY);
>     case PSN_HASHELP:           return sizeof(PSHNOTIFY);   // not used
>     case PSN_HELP:              return sizeof(PSHNOTIFY);
>     case PSN_WIZBACK:           return sizeof(PSHNOTIFY);
>     case PSN_WIZNEXT:           return sizeof(PSHNOTIFY);
>     case PSN_WIZFINISH:         return sizeof(PSHNOTIFY);
>     case PSN_QUERYCANCEL:       return sizeof(PSHNOTIFY);
>     case PSN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
>     case PSN_LASTCHANCEAPPLY:   return sizeof(PSHNOTIFY);
>     case PSN_TRANSLATEACCELERATOR:
>                                 return sizeof(PSHNOTIFY);
>     case PSN_QUERYINITIALFOCUS: return sizeof(PSHNOTIFY);
3320,3359c3355,3383
<             case PSN_LASTCHANCEAPPLY:  // this is undocumented
<                 return sizeof(NMHDR);  // (in widows\inc\prshtp.h)
<             */
< 
<             default:
<                 goto unknown_nmhdr_code;
<         }
<     }
< 
<     if (pnmhdr32->code >= HDN_LAST) {
<         LOGDEBUG(2,("%sHDN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
<             case HDN_ITEMCHANGINGA:
<             case HDN_ITEMCHANGEDA:
<             case HDN_ITEMCLICKA:
<             case HDN_DIVIDERDBLCLICKA:
<             case HDN_BEGINTRACKA:
<             case HDN_ENDTRACKA:
<             case HDN_TRACKA:
<             case HDN_ITEMCHANGINGW:
<             case HDN_ITEMCHANGEDW:
<             case HDN_ITEMCLICKW:
<             case HDN_DIVIDERDBLCLICKW:
<             case HDN_BEGINTRACKW:
<             case HDN_ENDTRACKW:
<             case HDN_TRACKW:
<             case HDN_BEGINDRAG:
<             case HDN_ENDDRAG:
<             case HDN_ITEMDBLCLICKA:
<             case HDN_ITEMDBLCLICKW:
<                 return sizeof(HD_NOTIFY);
< 
<             case HDN_GETDISPINFOA:
<             case HDN_GETDISPINFOW:
<                 return sizeof(NMHDDISPINFO);
< 
<             default:
<                 goto unknown_nmhdr_code;
<         }
<     }
---
>     // Header notifications
>     case HDN_ITEMCHANGINGA:     return sizeof(NMHEADERA);
>     case HDN_ITEMCHANGINGW:     return sizeof(NMHEADERW);
>     case HDN_ITEMCHANGEDA:      return sizeof(NMHEADERA);
>     case HDN_ITEMCHANGEDW:      return sizeof(NMHEADERW);
>     case HDN_ITEMCLICKA:        return sizeof(NMHEADERA);
>     case HDN_ITEMCLICKW:        return sizeof(NMHEADERW);
>     case HDN_ITEMDBLCLICKA:     return sizeof(NMHEADERA);
>     case HDN_ITEMDBLCLICKW:     return sizeof(NMHEADERW);
>     case HDN_DIVIDERDBLCLICKA:  return sizeof(NMHEADERA);
>     case HDN_DIVIDERDBLCLICKW:  return sizeof(NMHEADERW);
>     case HDN_BEGINTRACKA:       return sizeof(NMHEADERA);
>     case HDN_BEGINTRACKW:       return sizeof(NMHEADERW);
>     case HDN_ENDTRACKA:         return sizeof(NMHEADERA);
>     case HDN_ENDTRACKW:         return sizeof(NMHEADERW);
>     case HDN_TRACKA:            return sizeof(NMHEADERA);
>     case HDN_TRACKW:            return sizeof(NMHEADERW);
>     case HDN_GETDISPINFOA:      return sizeof(NMHDDISPINFOA);
>     case HDN_GETDISPINFOW:      return sizeof(NMHDDISPINFOW);
>     case HDN_BEGINDRAG:         return sizeof(NMHEADER); // No strings
>     case HDN_ENDDRAG:           return sizeof(NMHEADER); // No strings
>     case HDN_FILTERCHANGE:      return sizeof(NMHEADER); // No strings
>     case HDN_FILTERBTNCLICK:    return sizeof(NMHDFILTERBTNCLICK);
>     case HDN_BEGINFILTEREDIT:   return sizeof(NMHEADER);
>     case HDN_ENDFILTEREDIT:     return sizeof(NMHEADER);
>     case HDN_ITEMSTATEICONCLICK:return sizeof(NMHEADER);
>     case HDN_ITEMKEYDOWN:       return sizeof(NMHEADER);
>     case HDN_DROPDOWN:          return sizeof(NMHEADER);
>     case HDN_OVERFLOWCLICK:     return sizeof(NMHEADER);
3361,3393c3385,3419
<     if (pnmhdr32->code >= TVN_LAST) {
<         LOGDEBUG(2,("%sTVN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
<             case TVN_SELCHANGINGA:
<             case TVN_SELCHANGEDA:
<             case TVN_ITEMEXPANDINGA:
<             case TVN_ITEMEXPANDEDA:
<             case TVN_BEGINDRAGA:
<             case TVN_BEGINRDRAGA:
<             case TVN_DELETEITEMA:
<             case TVN_SELCHANGINGW:
<             case TVN_SELCHANGEDW:
<             case TVN_ITEMEXPANDINGW:
<             case TVN_ITEMEXPANDEDW:
<             case TVN_BEGINDRAGW:
<             case TVN_BEGINRDRAGW:
<             case TVN_DELETEITEMW:
<             
<             // FIXME: Enable the following when we are ready.
<             /*
<             case TVN_SINGLEEXPAND:
<                 return sizeof(NM_TREEVIEW);
<             */
< 
<             case TVN_GETDISPINFOA:
<             case TVN_SETDISPINFOA:
<             case TVN_BEGINLABELEDITA:
<             case TVN_ENDLABELEDITA:
<             case TVN_GETDISPINFOW:
<             case TVN_SETDISPINFOW:
<             case TVN_BEGINLABELEDITW:
<             case TVN_ENDLABELEDITW:
<                 return sizeof(TV_DISPINFO);
---
>     // Treeview notifications
>     case TVN_SELCHANGINGA:      return sizeof(NMTREEVIEWA);
>     case TVN_SELCHANGINGW:      return sizeof(NMTREEVIEWW);
>     case TVN_SELCHANGEDA:       return sizeof(NMTREEVIEWA);
>     case TVN_SELCHANGEDW:       return sizeof(NMTREEVIEWW);
>     case TVN_GETDISPINFOA:      return sizeof(NMTVDISPINFOA);
>     case TVN_GETDISPINFOW:      return sizeof(NMTVDISPINFOW);
>     case TVN_SETDISPINFOA:      return sizeof(NMTVDISPINFOA);
>     case TVN_SETDISPINFOW:      return sizeof(NMTVDISPINFOW);
>     case TVN_ITEMEXPANDINGA:    return sizeof(NMTREEVIEWA);
>     case TVN_ITEMEXPANDINGW:    return sizeof(NMTREEVIEWW);
>     case TVN_ITEMEXPANDEDA:     return sizeof(NMTREEVIEWA);
>     case TVN_ITEMEXPANDEDW:     return sizeof(NMTREEVIEWW);
>     case TVN_BEGINDRAGA:        return sizeof(NMTREEVIEWA);
>     case TVN_BEGINDRAGW:        return sizeof(NMTREEVIEWW);
>     case TVN_BEGINRDRAGA:       return sizeof(NMTREEVIEWA);
>     case TVN_BEGINRDRAGW:       return sizeof(NMTREEVIEWW);
>     case TVN_DELETEITEMA:       return sizeof(NMTREEVIEWA);
>     case TVN_DELETEITEMW:       return sizeof(NMTREEVIEWW);
>     case TVN_BEGINLABELEDITA:   return sizeof(NMTVDISPINFOA);
>     case TVN_BEGINLABELEDITW:   return sizeof(NMTVDISPINFOW);
>     case TVN_ENDLABELEDITA:     return sizeof(NMTVDISPINFOA);
>     case TVN_ENDLABELEDITW:     return sizeof(NMTVDISPINFOW);
>     case TVN_KEYDOWN:           return sizeof(NMTVKEYDOWN);
>     case TVN_GETINFOTIPA:       return sizeof(NMTVGETINFOTIPA);
>     case TVN_GETINFOTIPW:       return sizeof(NMTVGETINFOTIPW);
>     case TVN_SINGLEEXPAND:      return sizeof(NMTREEVIEW); // No strings
>     case TVN_ITEMCHANGINGA:     return sizeof(NMTVITEMCHANGE);
>     case TVN_ITEMCHANGINGW:     return sizeof(NMTVITEMCHANGE);
>     case TVN_ITEMCHANGEDA:      return sizeof(NMTVITEMCHANGE);
>     case TVN_ITEMCHANGEDW:      return sizeof(NMTVITEMCHANGE);
>     case TVN_ASYNCDRAW:         return sizeof(NMTVASYNCDRAW);
> 
>     // Rundll32 notifications
>     case RDN_TASKINFO:          return sizeof(RUNDLL_NOTIFY);
3395,3396c3421,3426
<             case TVN_KEYDOWN:
<                 return sizeof(TV_KEYDOWN);
---
>     // Tooltip notifications
>     case TTN_GETDISPINFOA:      return sizeof(NMTTDISPINFOA);
>     case TTN_GETDISPINFOW:      return sizeof(NMTTDISPINFOW);
>     case TTN_SHOW:              return sizeof(NMTTSHOWINFO);
>     case TTN_POP:               return sizeof(NMHDR);
>     case TTN_LINKCLICK:         return 0;
3398,3403c3428,3460
<             // FIXME: Enable the following when we are ready.
<             /*
<             case TVN_GETINFOTIPA:
<             case TVN_GETINFOTIPW:
<                 return sizeof(NMTVGETINFOTIP);
<             */
---
>     // Tab control notifications
> 
>     // WE ARE SUCH HORRIBLE SLACKERS!
>     //
>     //  Even though commctrl.h says that the shell reserved range is from
>     //  -580 to -589, shsemip.h defines SEN_FIRST as -550, which conflicts
>     //  with TCN_KEYDOWN, so now TCN_KEYDOWN and SEN_DDEEXECUTE have the
>     //  same value.
> 
>     case TCN_KEYDOWN:           return max(sizeof(NMTCKEYDOWN),
>                                            sizeof(NMVIEWFOLDERW));
>     case TCN_SELCHANGE:         return sizeof(NMHDR);
>     case TCN_SELCHANGING:       return sizeof(NMHDR);
>     case TCN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
>     case TCN_FOCUSCHANGE:       return sizeof(NMHDR);
> 
>     // Comdlg32 notifications
>     case CDN_INITDONE:          return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_SELCHANGE:         return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_FOLDERCHANGE:      return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_SHAREVIOLATION:    return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_HELP:              return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_FILEOK:            return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_TYPECHANGE:        return max(sizeof(OFNOTIFYA),
>                                            sizeof(OFNOTIFYW));
>     case CDN_INCLUDEITEM:       return max(sizeof(OFNOTIFYEXA),
>                                            sizeof(OFNOTIFYEXW));
3405,3408c3462,3493
<             default:
<                 goto unknown_nmhdr_code;
<         }
<     }
---
>     // Toolbar notifications
>     case TBN_GETBUTTONINFOA:    return sizeof(NMTOOLBARA);
>     case TBN_GETBUTTONINFOW:    return sizeof(NMTOOLBARW);
>     case TBN_BEGINDRAG:         return sizeof(NMTOOLBAR); // No strings
>     case TBN_ENDDRAG:           return sizeof(NMTOOLBAR); // No strings
>     case TBN_BEGINADJUST:       return sizeof(NMHDR);
>     case TBN_ENDADJUST:         return sizeof(NMHDR);
>     case TBN_RESET:             return sizeof(NMTBCUSTOMIZEDLG);
>     case TBN_QUERYINSERT:       return sizeof(NMTOOLBAR); // No strings
>     case TBN_QUERYDELETE:       return sizeof(NMTOOLBAR); // No strings
>     case TBN_TOOLBARCHANGE:     return sizeof(NMHDR);
>     case TBN_CUSTHELP:          return sizeof(NMHDR);
>     case TBN_DROPDOWN:          return sizeof(NMTOOLBAR); // No strings
>     case TBN_CLOSEUP:           return sizeof(NMHDR);     // not used
>     case TBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
>     case TBN_HOTITEMCHANGE:     return sizeof(NMTBHOTITEM);
>     case TBN_DRAGOUT:           return sizeof(NMTOOLBAR); // No strings
>     case TBN_DELETINGBUTTON:    return sizeof(NMTOOLBAR); // No strings
>     case TBN_GETDISPINFOA:      return sizeof(NMTBDISPINFOA);
>     case TBN_GETDISPINFOW:      return sizeof(NMTBDISPINFOW);
>     case TBN_GETINFOTIPA:       return sizeof(NMTBGETINFOTIPA);
>     case TBN_GETINFOTIPW:       return sizeof(NMTBGETINFOTIPW);
>     case TBN_RESTORE:           return sizeof(NMTBRESTORE);
> 
>     // WE ARE SUCH HORRIBLE SLACKERS!
>     //
>     //  The TBN_FIRST/TBN_LAST range reserves 20 notifications for toolbar,
>     //  and we overflowed that limit, so now UDN_DELTAPOS and
>     //  TBN_SAVE have the same value.
> 
>     case TBN_SAVE:              return max(sizeof(NMTBSAVE),
>                                            sizeof(NMUPDOWN));
3410,3414c3495,3500
<     if (pnmhdr32->code >= TTN_LAST) {
<         LOGDEBUG(2,("%sTTN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
<             case TTN_NEEDTEXTA:        // (aka TTN_GETDISPINFO)
<                 return sizeof(TOOLTIPTEXTA);
---
>     case TBN_INITCUSTOMIZE:     return sizeof(NMTBCUSTOMIZEDLG);
>     case TBN_WRAPHOTITEM:       return sizeof(NMTBWRAPHOTITEM);
>     case TBN_DUPACCELERATOR:    return sizeof(NMTBDUPACCELERATOR);
>     case TBN_WRAPACCELERATOR:   return sizeof(NMTBWRAPACCELERATOR);
>     case TBN_DRAGOVER:          return sizeof(NMTBHOTITEM);
>     case TBN_MAPACCELERATOR:    return sizeof(NMCHAR);
3416,3417c3502,3519
<             case TTN_NEEDTEXTW:
<                 return sizeof(TOOLTIPTEXTW);
---
>     // Monthcal control
>     case MCN_SELCHANGE:         return sizeof(NMSELCHANGE);
>     case MCN_GETDAYSTATE:       return sizeof(NMDAYSTATE);
>     case MCN_SELECT:            return sizeof(NMSELECT);
>     case MCN_VIEWCHANGE:        return sizeof(NMVIEWCHANGE);
> 
>     // Date/time picker control
>     case DTN_DATETIMECHANGE:    return sizeof(NMDATETIMECHANGE);
>     case DTN_USERSTRINGA:       return sizeof(NMDATETIMESTRINGA);
>     case DTN_USERSTRINGW:       return sizeof(NMDATETIMESTRINGW);
>     case DTN_WMKEYDOWNA:        return sizeof(NMDATETIMEWMKEYDOWNA);
>     case DTN_WMKEYDOWNW:        return sizeof(NMDATETIMEWMKEYDOWNW);
>     case DTN_FORMATA:           return sizeof(NMDATETIMEFORMATA);
>     case DTN_FORMATW:           return sizeof(NMDATETIMEFORMATW);
>     case DTN_FORMATQUERYA:      return sizeof(NMDATETIMEFORMATQUERYA);
>     case DTN_FORMATQUERYW:      return sizeof(NMDATETIMEFORMATQUERYW);
>     case DTN_DROPDOWN:          return sizeof(NMHDR);
>     case DTN_CLOSEUP:           return sizeof(NMHDR);
3419,3421c3521,3531
<             case TTN_SHOW:
<             case TTN_POP:
<                 return sizeof(NMHDR);
---
>     // Comboex notifications
>     case CBEN_GETDISPINFOA:     return sizeof(NMCOMBOBOXEXA);
>     case CBEN_GETDISPINFOW:     return sizeof(NMCOMBOBOXEXW);
>     case CBEN_INSERTITEM:       return sizeof(NMCOMBOBOXEX); // Random character set
>     case CBEN_DELETEITEM:       return sizeof(NMCOMBOBOXEX); // No strings
>     case CBEN_ITEMCHANGED:      return sizeof(NMCOMBOBOXEX); // Not used
>     case CBEN_BEGINEDIT:        return sizeof(NMHDR);
>     case CBEN_ENDEDITA:         return sizeof(NMCBEENDEDITA);
>     case CBEN_ENDEDITW:         return sizeof(NMCBEENDEDITW);
>     case CBEN_DRAGBEGINA:       return sizeof(NMCBEDRAGBEGINA);
>     case CBEN_DRAGBEGINW:       return sizeof(NMCBEDRAGBEGINW);
3423,3432c3533,3567
<             default:
<                 goto unknown_nmhdr_code;
<         }
<     }
< 
<     if (pnmhdr32->code >= TCN_LAST) {
<         LOGDEBUG(2,("%sTCN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
<             case TCN_KEYDOWN:
<                 return sizeof(TC_KEYDOWN);
---
>     // Rebar notifications
>     case RBN_HEIGHTCHANGE:      return sizeof(NMHDR);
>     case RBN_GETOBJECT:         return sizeof(NMOBJECTNOTIFY);
>     case RBN_LAYOUTCHANGED:     return sizeof(NMHDR);
>     case RBN_AUTOSIZE:          return sizeof(NMRBAUTOSIZE);
>     case RBN_BEGINDRAG:         return sizeof(NMREBAR);
>     case RBN_DELETINGBAND:      return sizeof(NMREBAR);
>     case RBN_DELETEDBAND:       return sizeof(NMREBAR);
>     case RBN_CHILDSIZE:         return sizeof(NMREBARCHILDSIZE);
>     case RBN_CHEVRONPUSHED:     return sizeof(NMREBARCHEVRON);
>     case RBN_SPLITTERDRAG:      return sizeof(NMREBARSPLITTER);
>     case RBN_MINMAX:            return 0;
>     case RBN_AUTOBREAK:         return sizeof(NMREBARAUTOBREAK);
> 
>     // IP address control notification
>     case IPN_FIELDCHANGED:      return sizeof(NMIPADDRESS);
> 
>     // Status bar notifications
>     case SBN_SIMPLEMODECHANGE:  return sizeof(NMHDR);
> 
>     // Pager control notifications
>     case PGN_SCROLL:            return sizeof(NMPGSCROLL);
>     case PGN_CALCSIZE:          return sizeof(NMPGCALCSIZE);
>     case PGN_HOTITEMCHANGE:     return sizeof(NMPGHOTITEM);
>     
>     // Button control notifications
>     case BCN_HOTITEMCHANGE:     return sizeof(NMBCHOTITEM);
> 
>     default:
>         break;
>     }
> 
>     //
>     //  Categories of notifications we explicitly know nothing about.
>     //
3434,3440c3569,3570
<             case TCN_SELCHANGE:
<             case TCN_SELCHANGING:
<                 return sizeof(NMHDR);
< 
<             default:
<                 goto unknown_nmhdr_code;
<         }
---
>     if (pnmhdr32->code >= WMN_LAST && pnmhdr32->code <= WMN_FIRST) { // Internet Mail and News
>         return sizeof(NMHDR);
3443,3454d3572
<     if (pnmhdr32->code >= UDN_LAST) {
<         LOGDEBUG(2,("%sUDN_ %x\n", szLabel, pnmhdr32->code));
<         switch (pnmhdr32->code) {
<             case UDN_DELTAPOS:
<                 return sizeof(NM_UPDOWN);
< 
<             default:
<                 goto unknown_nmhdr_code;
<         }
<     }
< 
< unknown_nmhdr_code:
--- NT4\private\mvdm\wow32\wgdi.c
+++ nt\private\mvdm\wow32\wgdi.c
1686,1687d1685
<         // FIXME: Enable the following when we are ready.
<         /*
1742d1739
<         */
--- NT4\private\mvdm\wow32\wparam.c
+++ nt\private\mvdm\wow32\wparam.c
359c359
<             LOGDEBUG(12, ("\nWOW: DeleteParamMap called refCount > 0 Node@%x\n", (DWORD)lpn));
---
>             LOGDEBUG(12, ("\nWOW: DeleteParamMap called refCount %d > 0 Node@%x\n", lpn->dwRefCount, (DWORD)lpn));
--- NT4\private\mvdm\wow32\wuclass.h
+++ nt\private\mvdm\wow32\wuclass.h
26a27,29
> #ifdef W10
> LRESULT CALLBACK W32Win16WndDispProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
> #endif
--- NT4\private\mvdm\wow32\wudlg.h
+++ nt\private\mvdm\wow32\wudlg.h
40a41,43
> #ifdef W10
> BOOL  CALLBACK   W32Win16DlgDispProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
> #endif
--- NT4\private\mvdm\wow32\wudlg.h
+++ nt\private\mvdm\wow32\wudlg.h
21a22,48
> /* WOW class/handle type identifiers (see WARNING below)
>  */
> #define WOWCLASS_UNKNOWN    0   // here begin our "window handle" classes
> #define WOWCLASS_WIN16      1
> #define WOWCLASS_BUTTON     2
> #define WOWCLASS_COMBOBOX   3
> #define WOWCLASS_EDIT       4
> #define WOWCLASS_LISTBOX    5
> #define WOWCLASS_MDICLIENT  6
> #define WOWCLASS_SCROLLBAR  7
> #define WOWCLASS_STATIC     8
> #define WOWCLASS_DESKTOP    9
> #define WOWCLASS_DIALOG     10
> #define WOWCLASS_ICONTITLE  11
> #define WOWCLASS_MENU       12
> #define WOWCLASS_SWITCHWND  13
> #define WOWCLASS_COMBOLBOX  14
> #define WOWCLASS_MAX        14  // Always equal to the last value used.
> 
> #define WOWCLASS_NOTHUNK    0xFF // not an actual class index
> //
> // WARNING! The above sequence and values must be maintained otherwise the
> // table in WMSG16.C for message thunking must be changed.  Same goes for
> // table in WALIAS.C.
> //
> 
> 
--- NT4\private\mvdm\wow32\walias.c
+++ nt\private\mvdm\wow32\walias.c
626a627
>     LONG   Pid;
629a631
>     LONG   l4;
--- NT4\private\mvdm\wow32\wuman.c
+++ nt\private\mvdm\wow32\wuman.c
110d109
<                 PSZ pszFormat;
189,194c188,189
<                         if ( i & 3 ) {
<                             pszFormat = ", %s";
<                         } else {
<                             pszFormat = "\n%s";
<                         }
<                         LOGDEBUG(LOG_TRACE, (pszFormat, aw32Msg[wMsg].lpszW32));
---
>                         if (aw32Msg[wMsg].lpszW32) {LOGDEBUG(LOG_TRACE, ((( i & 3 )?", %s":"\n%s"), aw32Msg[wMsg].lpszW32));}
>                         else {LOGDEBUG(LOG_TRACE, ((( i & 3 )?", UNKNOWN (%d)":"\n UNKNOWN (%d)"), wMsg));}
--- NT4\private\mvdm\wow32\wmtbl32.c
+++ nt\private\mvdm\wow32\wmtbl32.c
213c213
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_LPKDRAWSWITCHWND")},
219,225c219,225
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHDESTROYWINDOW")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHDRAWMENU")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHDRAWMENUITEM")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHINITMENU")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHMEASUREMENUITEM")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHNCPAINTMENUPOPUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHUPDATE")},
252,256c252,256
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCXBUTTONDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCXBUTTONUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCXBUTTONDBLCLK")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCUAHDRAWCAPTION")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCUAHDRAWFRAME")},
308a309,310
>     {W32MSGFUN(WM32UNDOCUMENTED,      "EM_SETIMESTATUS")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "EM_GETIMESTATUS")},
310,311d311
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
355,356c355,356
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_INPUT_DEVICE_CHANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_INPUT")},
370c370
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UNICHAR")},
390,393c390,393
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTURE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTURENOTIFY")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTUREINPUT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GESTURENOTIFIED")},
480a481,483
>     {W32MSGFUN(WM32UNDOCUMENTED,      "CB_MSGMAX_OLD")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "CB_MULTIPLEADDSTRING")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "CB_GETCOMBOBOXINFO")},
482,484d484
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
578a579,581
>     {W32MSGFUN(WM32UNDOCUMENTED,      "LB_MSGMAX_OLD")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "LB_MULTIPLEADDSTRING")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "LB_GETLISTBOXINFO")},
580,582d582
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
691,695c691,695
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSEWHEEL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_XBUTTONDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_XBUTTONUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_XBUTTONDBLCLK")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSEHWHEEL")},
749,754c749,754
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICECHANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEINRANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEOUTOFRANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_STOPINERTIA")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_ENDINERTIA")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_EDGYINERTIA")},
759,766c759,766
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TOUCH")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERUPDATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERUP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCPOINTERLAST")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERUPDATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERUP")},
770,776c770,776
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERENTER")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERLEAVE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERACTIVATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERCAPTURECHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TOUCHHITTESTING")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERWHEEL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERHWHEEL")},
786c786
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERLAST")},
819,822c819,822
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_VISIBILITYCHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_VIEWSTATECHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UNREGISTER_WINDOW_SERVICES")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_CONSOLIDATED")},
883,886c883,886
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCMOUSEHOVER")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSEHOVER")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_NCMOUSELEAVE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MOUSELEAVE")},
900c900
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TRACKMOUSEEVENT_LAST")},
904c904
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_WTSSESSION_CHANGE")},
923c923
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TABLET_FIRST")},
933,934c933,934
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEADDED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_POINTERDEVICEDELETED")},
936c936
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FLICK")},
938,939c938,939
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FLICKINTERNAL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_BRIGHTNESSCHANGED")},
960c960
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_TABLET_LAST")},
963c963
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DPICHANGED")},
1034,1040c1034,1040
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_APPCOMMAND")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_THEMECHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UAHINIT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DESKTOPNOTIFY")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_CLIPBOARDUPDATE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMCOMPOSITIONCHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMNCRENDERINGCHANGED")},
1043,1050c1043,1050
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMCOLORIZATIONCOLORCHANGED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMWINDOWMAXIMIZEDCHANGE")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMEXILEFRAME")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMSENDICONICTHUMBNAIL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MAGNIFICATION_STARTED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MAGNIFICATION_ENDED")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMSENDICONICLIVEPREVIEWBITMAP")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMTHUMBNAILSIZECHANGED")},
1053,1055c1053,1055
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MAGNIFICATION_OUTPUT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_BSDRDATA")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_DWMTRANSITIONSTATECHANGED")},
1057,1060c1057,1060
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_KEYBOARDCORRECTIONCALLOUT")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_KEYBOARDCORRECTIONACTION")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_UIACTION")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_ROUTED_UI_EVENT")},
1063,1064c1063,1064
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_MEASURECONTROL")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GETACTIONTEXT")},
1066,1067c1066,1067
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FORWARDKEYDOWN")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_FORWARDKEYUP")},
1079,1080c1079,1080
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
<     {W32MSGFUN(WM32UNDOCUMENTED,      NULL)},
---
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_CE_ONLY_LAST")},
>     {W32MSGFUN(WM32UNDOCUMENTED,      "WM_GETTITLEBARINFOEX")},
--- NT4\private\mvdm\wow32\wcuricon.c
+++ nt\private\mvdm\wow32\wcuricon.c
1101c1101
<          WOW32ASSERT(h32);
---
>          //WOW32ASSERT(h32);
--- NT4\private\mvdm\wow32\wdib.c
+++ nt\private\mvdm\wow32\wdib.c
297c297
< #ifndef i386
---
> #ifndef MONITOR
422c422
< #ifndef i386
---
> #ifndef MONITOR
655c655
< #ifndef i386
---
> #ifndef MONITOR
711c711
< #ifndef i386
---
> #ifndef MONITOR
736c736
< #ifndef i386
---
> #ifndef MONITOR
837c837
< #ifndef i386
---
> #ifndef MONITOR
--- NT4\private\mvdm\wow32\wuser31.c
+++ nt\private\mvdm\wow32\wuser31.c
133a134
>     DECLARE_THUNKLOCK
138a140
>     RELEASE_THUNKLOCK
142a145
>     RESTORE_THUNKLOCK
192c195
< #ifndef _X86_
---
> #ifndef _X86xx_
266c269
< #ifndef _X86_
---
> #ifndef _X86xx_
294c297
< #ifndef _X86_
---
> #ifndef _X86xx_
525c528
< #ifndef _X86_
---
> #ifndef _X86xx_
545c548
< #ifndef _X86_
---
> #ifndef _X86xx_
628c631
< #ifndef _X86_
---
> #ifndef _X86xx_
--- NT4\private\mvdm\wow32\wkmem.c
+++ nt\private\mvdm\wow32\wkmem.c
33c33
< #ifndef i386
---
> #ifndef MONITOR
40c40
< #ifndef i386
---
> #ifndef MONITOR
48c48
< #endif // i386
---
> #endif // MONITOR
56c56
< #ifndef i386
---
> #ifndef MONITOR
63c63
< #endif // i386
---
> #endif // MONITOR
65c65
< #ifdef i386
---
> #ifdef MONITOR
104c104
< #ifndef i386
---
> #ifndef MONITOR
120,121c120,121
< #ifndef i386
<     Status = VdmFreeVirtualMemory( glpvDelayFree[gdwDelayFree]);
---
> #ifndef MONITOR
>     Status = VdmFreeVirtualMemory( (ULONG)glpvDelayFree[gdwDelayFree]);
132c132
< #ifndef i386
---
> #ifndef MONITOR
134c134
< #endif // i386
---
> #endif // MONITOR
--- NT4\private\mvdm\wow32\wole2.c
+++ nt\private\mvdm\wow32\wole2.c
159c159
<     ullOldest = -1;
---
>     ullOldest = (ULONGLONG)-1;
--- NT4\private\mvdm\wow32\wkgthunk.c
+++ nt\private\mvdm\wow32\wkgthunk.c
301a302
>     DECLARE_THUNKLOCK
321a323
>     RELEASE_THUNKLOCK
322a325
>     RESTORE_THUNKLOCK
405a409
>     DECLARE_THUNKLOCK
417a422
>     RELEASE_THUNKLOCK
418a424
>     RESTORE_THUNKLOCK
559a566
>     DECLARE_THUNKLOCK
663a671
>     RELEASE_THUNKLOCK
668a677
>     RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\wuser.c
+++ nt\private\mvdm\wow32\wuser.c
2281a2282
> 	DECLARE_THUNKLOCK
2361a2363
> 	RELEASE_THUNKLOCK
2362a2365
> 	RESTORE_THUNKLOCK
--- NT4\private\mvdm\wow32\sources.inc
+++ nt\private\mvdm\wow32\sources.inc
31,32c31,32
<     #$(SDK_LIB_PATH)\userenv.lib
<     #$(WINDOWS_LIB_PATH)\apphelp.lib \
---
>     $(SDK_LIB_PATH)\userenv.lib \
>     $(WINDOWS_LIB_PATH)\apphelp.lib 
133,134c133,135
<     ..\hack.c
< #   ..\wshimdb.c   \
---
>     ..\wshimdb.c   \
>     ..\wsyslevel.c \
>     ..\wtask.c
